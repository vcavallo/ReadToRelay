{
  "version": 3,
  "sources": ["../../nipb7.ts", "../../utils.ts"],
  "sourcesContent": ["import { sha256 } from '@noble/hashes/sha256'\nimport { EventTemplate } from './core.ts'\nimport { Signer } from './signer.ts'\nimport { bytesToHex } from './utils.ts'\n\nexport type BlobDescriptor = {\n  url: string\n  sha256: string\n  size: number\n  type: string\n  uploaded: number\n}\n\nexport class BlossomClient {\n  private mediaserver: string\n  private signer: Signer\n\n  constructor(mediaserver: string, signer: Signer) {\n    if (!mediaserver.startsWith('http')) {\n      mediaserver = 'https://' + mediaserver\n    }\n    this.mediaserver = mediaserver.replace(/\\/$/, '') + '/'\n    this.signer = signer\n  }\n\n  private async httpCall(\n    method: string,\n    url: string,\n    contentType?: string,\n    addAuthorization?: () => Promise<string>,\n    body?: File | Blob,\n    result?: any,\n  ): Promise<any> {\n    const headers: { [_: string]: string } = {}\n\n    if (contentType) {\n      headers['Content-Type'] = contentType\n    }\n\n    if (addAuthorization) {\n      const auth = await addAuthorization()\n      if (auth) {\n        headers['Authorization'] = auth\n      }\n    }\n\n    const response = await fetch(this.mediaserver + url, {\n      method,\n      headers,\n      body,\n    })\n\n    if (response.status >= 300) {\n      const reason = response.headers.get('X-Reason') || response.statusText\n      throw new Error(`${url} returned an error (${response.status}): ${reason}`)\n    }\n\n    if (result !== null && response.headers.get('content-type')?.includes('application/json')) {\n      return await response.json()\n    }\n\n    return response\n  }\n\n  private async authorizationHeader(modify?: (event: EventTemplate) => void): Promise<string> {\n    const now = Math.floor(Date.now() / 1000)\n    const event: EventTemplate = {\n      created_at: now,\n      kind: 24242,\n      content: 'blossom stuff',\n      tags: [['expiration', String(now + 60)]],\n    }\n\n    if (modify) {\n      modify(event)\n    }\n\n    try {\n      const signedEvent = await this.signer.signEvent(event)\n      const eventJson = JSON.stringify(signedEvent)\n      return 'Nostr ' + btoa(eventJson)\n    } catch (error) {\n      return ''\n    }\n  }\n\n  private isValid32ByteHex(hash: string): boolean {\n    return /^[a-f0-9]{64}$/i.test(hash)\n  }\n\n  async check(hash: string): Promise<void> {\n    if (!this.isValid32ByteHex(hash)) {\n      throw new Error(`${hash} is not a valid 32-byte hex string`)\n    }\n\n    try {\n      await this.httpCall('HEAD', hash)\n    } catch (error) {\n      throw new Error(`failed to check for ${hash}: ${error}`)\n    }\n  }\n\n  async uploadBlob(file: File | Blob, contentType?: string): Promise<BlobDescriptor> {\n    const hash = bytesToHex(sha256(new Uint8Array(await file.arrayBuffer())))\n    const actualContentType = contentType || file.type || 'application/octet-stream'\n\n    const bd = await this.httpCall(\n      'PUT',\n      'upload',\n      actualContentType,\n      () =>\n        this.authorizationHeader(evt => {\n          evt.tags.push(['t', 'upload'])\n          evt.tags.push(['x', hash])\n        }),\n      file,\n      {},\n    )\n\n    return bd\n  }\n\n  async uploadFile(file: File): Promise<BlobDescriptor> {\n    return this.uploadBlob(file, file.type)\n  }\n\n  async download(hash: string): Promise<ArrayBuffer> {\n    if (!this.isValid32ByteHex(hash)) {\n      throw new Error(`${hash} is not a valid 32-byte hex string`)\n    }\n\n    const authHeader = await this.authorizationHeader(evt => {\n      evt.tags.push(['t', 'get'])\n      evt.tags.push(['x', hash])\n    })\n\n    const response = await fetch(this.mediaserver + hash, {\n      method: 'GET',\n      headers: {\n        Authorization: authHeader,\n      },\n    })\n\n    if (response.status >= 300) {\n      throw new Error(`${hash} is not present in ${this.mediaserver}: ${response.status}`)\n    }\n\n    return await response.arrayBuffer()\n  }\n\n  async downloadAsBlob(hash: string): Promise<Blob> {\n    const arrayBuffer = await this.download(hash)\n    return new Blob([arrayBuffer])\n  }\n\n  async list(): Promise<BlobDescriptor[]> {\n    const pubkey = await this.signer.getPublicKey()\n\n    if (!this.isValid32ByteHex(pubkey)) {\n      throw new Error(`pubkey ${pubkey} is not valid`)\n    }\n\n    try {\n      const bds = await this.httpCall(\n        'GET',\n        `list/${pubkey}`,\n        undefined,\n        () =>\n          this.authorizationHeader(evt => {\n            evt.tags.push(['t', 'list'])\n          }),\n        undefined,\n        [],\n      )\n      return bds\n    } catch (error) {\n      throw new Error(`failed to list blobs: ${error}`)\n    }\n  }\n\n  async delete(hash: string): Promise<void> {\n    if (!this.isValid32ByteHex(hash)) {\n      throw new Error(`${hash} is not a valid 32-byte hex string`)\n    }\n\n    try {\n      await this.httpCall(\n        'DELETE',\n        hash,\n        undefined,\n        () =>\n          this.authorizationHeader(evt => {\n            evt.tags.push(['t', 'delete'])\n            evt.tags.push(['x', hash])\n          }),\n        undefined,\n        null,\n      )\n    } catch (error) {\n      throw new Error(`failed to delete ${hash}: ${error}`)\n    }\n  }\n}\n", "import type { Event } from './core.ts'\n\nexport const utf8Decoder: TextDecoder = new TextDecoder('utf-8')\nexport const utf8Encoder: TextEncoder = new TextEncoder()\n\nexport { bytesToHex, hexToBytes } from '@noble/hashes/utils'\n\nexport function normalizeURL(url: string): string {\n  try {\n    if (url.indexOf('://') === -1) url = 'wss://' + url\n    let p = new URL(url)\n    p.pathname = p.pathname.replace(/\\/+/g, '/')\n    if (p.pathname.endsWith('/')) p.pathname = p.pathname.slice(0, -1)\n    if ((p.port === '80' && p.protocol === 'ws:') || (p.port === '443' && p.protocol === 'wss:')) p.port = ''\n    p.searchParams.sort()\n    p.hash = ''\n    return p.toString()\n  } catch (e) {\n    throw new Error(`Invalid URL: ${url}`)\n  }\n}\n\nexport function insertEventIntoDescendingList(sortedArray: Event[], event: Event): Event[] {\n  const [idx, found] = binarySearch(sortedArray, b => {\n    if (event.id === b.id) return 0\n    if (event.created_at === b.created_at) return -1\n    return b.created_at - event.created_at\n  })\n  if (!found) {\n    sortedArray.splice(idx, 0, event)\n  }\n  return sortedArray\n}\n\nexport function insertEventIntoAscendingList(sortedArray: Event[], event: Event): Event[] {\n  const [idx, found] = binarySearch(sortedArray, b => {\n    if (event.id === b.id) return 0\n    if (event.created_at === b.created_at) return -1\n    return event.created_at - b.created_at\n  })\n  if (!found) {\n    sortedArray.splice(idx, 0, event)\n  }\n  return sortedArray\n}\n\nexport function binarySearch<T>(arr: T[], compare: (b: T) => number): [number, boolean] {\n  let start = 0\n  let end = arr.length - 1\n\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2)\n    const cmp = compare(arr[mid])\n\n    if (cmp === 0) {\n      return [mid, true]\n    }\n\n    if (cmp < 0) {\n      end = mid - 1\n    } else {\n      start = mid + 1\n    }\n  }\n\n  return [start, false]\n}\n\nexport class QueueNode<V> {\n  public value: V\n  public next: QueueNode<V> | null = null\n  public prev: QueueNode<V> | null = null\n\n  constructor(message: V) {\n    this.value = message\n  }\n}\n\nexport class Queue<V> {\n  public first: QueueNode<V> | null\n  public last: QueueNode<V> | null\n\n  constructor() {\n    this.first = null\n    this.last = null\n  }\n\n  enqueue(value: V): boolean {\n    const newNode = new QueueNode(value)\n    if (!this.last) {\n      // list is empty\n      this.first = newNode\n      this.last = newNode\n    } else if (this.last === this.first) {\n      // list has a single element\n      this.last = newNode\n      this.last.prev = this.first\n      this.first.next = newNode\n    } else {\n      // list has elements, add as last\n      newNode.prev = this.last\n      this.last.next = newNode\n      this.last = newNode\n    }\n    return true\n  }\n\n  dequeue(): V | null {\n    if (!this.first) return null\n\n    if (this.first === this.last) {\n      const target = this.first\n      this.first = null\n      this.last = null\n      return target.value\n    }\n\n    const target = this.first\n    this.first = target.next\n    if (this.first) {\n      this.first.prev = null // fix: clean up prev pointer\n    }\n\n    return target.value\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
